чОбязанности Katch

- [ ]  собрать classes
  - [ ]  хранить App (не глобально)
  - [ ]  пройти все файлы, добавить все в Katch.classes
  - [ ]  записать кэш-файл с зависимостями (поддержка больших проектов)
  - [ ]  прочитать кэш-файс с зависимостями (поддержка больших проектов)
  - [ ]  раннер, который пересчитывает файл с зависимостями на лету (поддержка больших проектов)
  - [ ]  собрать зависимости "от" и "к"
  - [ ]  собрать эвенты и реквесты
    - [ ]  event/requestPoint возвращает функцию (конструктор эвента/реквеста)
      - [ ]  внутри этой функции он сохраняет аргументы
      - [ ]  присвоить хорошее имя эвента конструктору
- [ ]  инициализировать App
  - [ ]  прочитать App
  - [ ]  добавить в контекст все зависимые "от" и "к"
  - [ ]  создать контекст (не глобально) App.classes
  - [ ]  сконструировать все App.classes
  - [ ]  сбор зависимостей Event_* и Request_*
    - [ ]  запуск функций с Katch()
  - [ ]  бросить App.fire(App.Request_FailInit) у инициализированного App
  - [ ]  бросить App.fire(App.Event_Inited)
- [ ]  обработка fireEvent и fireRequest
  - [ ]  прочитать все зависимые classes и methods
  - [ ]  запустить все Katch-методы и словить требуемые эвенты и реквесты
  - [ ]  сопоставить аргументы и шаблоны в Katch (pattern matching)
  - [ ]  добавить в массив Katch.fired текущий эвент
  - [ ]  обработка fireEvent
    - [ ]  отсортировать обработчики эвентов по весу (сортировка эвентов)
    - [ ]  запустить по порядку (параллельно)
  - [ ]  обработка fireRequest
    - [ ]  отсортировать обработчики реквестов по весу (сортировка эвентов)
    - [ ]  запустить параллельно штуку которая проверяет, что запрос может быть исполнен
    - [ ]  запускать по очереди методы, которые отрапортовали, что могут исполнить запрос
  - [ ]  запустить еще раз методы, которые отработали, чтобы еще раз получить готовые к работе методы
  - [ ]  работа функции Katch
    - [ ]  режим "сбор методов"
      - [ ]  при инициализации выставить Katch.mode = 2
      - [ ]  функция делает throw Katch
      - [ ]  к каждому перечисленному эвенту записать список методов, которые его ловят
    - [ ]  режим "запуск с параметрами"
      - [ ]  при инициализации выставить Katch.mode = 1
      - [ ]  вернуть текущий event или request из Katch.fired[0]
  - [ ]  работа функции fire
  - [ ]  удалить из Katch.fired текущий эвент
  - [ ]  работа паттерн матчинга (pattern matching)
    - [ ]  работа функции _
      - [ ]  режим чтения аргумемнтов к эвенту
        - [ ]  сопоставление позиционных аргументов
          - [ ]  чтение path из proxy
          - [ ]  в каждом эвенте сохранение позиций и паттерна
      - [ ]  холостой режим
    - [ ]  вызоа метода для сбора данных
      - [ ]  каждый аргумент - это Proxy, который собирает path
    - [ ]  рабочий вызов метода
  - [ ]  конструктор эвента / реквеста
    - [ ]  режим сбора данных
      - [ ]  записывает куда-то к себе, какие аргументы к нему пришли
  - [ ]  Katch.apply и Katch.reject
    - [ ]  режим применение реквеста
      - [ ]  к текущему реквесту добавлять
    - [ ]  режим запуска функции или катч эвента
- [ ]  запуск тестов
  - [ ]  перед исполнением кода
    - [ ]  создание отдельного контекста (контекстов)
    - [ ]  инстанцирование модулей

Фичи:

- [ ]  fireEvent / catchEvent
- [ ]  fireEvent(Request) / catchEvent(Request)
- [ ]  fireRequest / catchRequest
- [ ]  fireRequest(Event) / catchRequest(Event)
- [ ]  test context
- [ ]

Что сделать:

- [ ]  отработать фильтр (у реквестов и у эвентов)

Что еще доделать:

- [ ]  сделать конструкторы контекстов статическими, имя классов начинается с construct...
- [ ]  сделать конструктор контекстов для тестов, статический метод constructForTest(class, methodName)
- [ ]  в scanMethodsAndSubscribe заменить contexts.App на другое (чтобы сработало для тестов)

Алгоритм Katch.Request:

- [ ]  накопить обработчики
  - [ ]  ловим await Katch.apply(priority) или Katch.reject()
- [ ]  вызвать приоритетный обработчик

варианты:
